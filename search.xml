<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[使用cocos studio制作动画]]></title>
      <url>%2F2017%2F08%2F04%2Fusing-cocos-studio-animation%2F</url>
      <content type="text"><![CDATA[概述虽然触控不维护cocos studio了，但是很多人却还在使用着，比如我们公司就还用着，因为需要做动画。但是我不会，只会代码去写动画，太费时间了有没有啊，所以就决定去哪就下怎么用编辑器去做动画了。现在把过程记录下来，以便日后复习。 动画只是简单的移动、旋转淡入淡出等简单的动画，创建步奏如下： 首先新建一个节点，见下图： 拖一个Text控件到我们刚创建的节点上面。然后我们就可切入正题开始做动画了。 点击“+”号创建一个动画 点击“+”后会弹出一个对话框，如下 动画创建好了，我们可以开始编辑动画了。这里我们使用自动记录动画的功能这样比较方便。按钮在这里啦 选择“开始记录动画”以后我们就可以开始编辑动画效果了。这里我们就让文字旋转360°吧。（1）首先第一帧不用管，直接插入关键帧就好了。（2）将插入位置移动到下一帧，然后修改旋转属性为“90°” 重复循环这一步骤，直到Text文字变换回到开始位置（0°） 取消勾选“开始记录动画”，到这里旋转动画就完成了。我们可以点击播放按钮看看效果。 有人肯定会问，那我们开始创建动画的时候填的名字有什么用呢。哈哈，不用急我的理解是当我们有多个动画的时候，名字就可以派上用场了。举个例子，有个角色有三个动画分别是“run”、“walk”和“attack”。我们在制作的时候就可以这么去做了。（1）0-20帧我们制作“run”的动画，动画的名字就叫做“run”。（2）25-45帧我们制作“walk”的动画，动画的名字就叫做“walk”。（2）50-70帧我们制作“attack”的动画，动画的名字就叫做“attack”。聪明的你是不是已经明白一切了。就是你想的那样。我们在代码中可以通过名字来播放相应的动画。是不是比用帧去播放容易记点呢。 用图片制作动画 很简单导入资源，你只需要选择好你需要的资源，然后把它拖入到cocos studio左下角的项目窗口就可以了。2.创建一个新的节点，然后在节点上新创建一个精灵。 在项目选择你需要的资源直接拖到我们刚创建的精灵上。好了大工告成，是不是很简单呢？ 发布资源 在发布资源之前记得把我们创建的两个节点放到场景中去。 当编辑好了动画就可以发布了。因为们这里没有有新建vs工程所以这里我选择发布vs工程，然后并打开它。 代码播放动画 在HelloWorld::init()中添加如下代码： 123456789ActionTimeline* action1 = CSLoader::createTimeline("spite1.csb");rootNode-&gt;getChildByName&lt;ui::Text*&gt;("sprite1")-&gt;runAction(action1);ActionTimeline* action2 = CSLoader::createTimeline("spite2.csb");rootNode-&gt;getChildByName&lt;Sprite*&gt;("sprite2")-&gt;runAction(action2);action1-&gt;gotoFrameAndPlay(0, true);//action1-&gt;play("ani2",true);action2-&gt;gotoFrameAndPlay(0, true); 好了，到现在为止，本教程就全部讲完了，按下F5看看效果吧。下面是我的效果：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[a*寻路算法总结]]></title>
      <url>%2F2017%2F08%2F03%2Fthinking-about-a-star-algorithm%2F</url>
      <content type="text"><![CDATA[概述最近想做一个RPG类型的游戏，对于RPG游戏而言寻路算法是非常必要的。现在将它记在博客以便日后复习。这里只是一个简单的实现，等空下来会用二叉堆（Binary Heaps）来实现。在计算机科学中，A*算法广泛应用于寻路和图的遍历。最早是于1968年，由Peter Hart, Nils Nilsson 和Bertram Raphael3人在斯坦福研究院描述了 该算法。是对Dijkstra算法的一种扩展。是一种高效的搜索算法。 这是个比较常用的算法，游戏中的寻路通常会使用这个算法，在理解这个算法之前，先明白几个概念： 搜索区域（The Search Area）搜索区域可以划分为正方形格子，但不限于此，六边形，矩形，平行四边形都可以。因此他们的中心点通常称为节点(Node)，而不是方格(Squares)。 ##路径排序(Path Sorting) 在没有任何障碍的地图上，一个节点可以有4个方向甚至8个方向移动可能。那么如何选择走那个路径呢，判断的依据就是这个公式：f = g + h; g是起点到指定格子的移动代价，h是指定格子到达终点的估算成本，f值则是两者之和。 假设横纵走一格的代价为10， 对角线为14，那么起点往左走一格的g值为10。 启发函数（Heuristics function）h值属于估算成本，不同的估算方法对应不同的结果。选取适合的估算方法需要根据实际场景而定。我们成这种估算函数为启发函数，例如，允许4个方向走，那么可以采用曼哈顿距离（Manhattan distance）， 即横向和竖向走到终点的距离之和。启发函数的作用在于，当你把启发代价设定的比实际代价更大时，那么搜索速度会变得更快，但结果可能不是最优的路径。相反，启发代价比实际的小，那么搜索变慢，得到一个最优路径。这是速度 与最优解之间的权衡 开放列表(Open List)开放列表实际上是一个待检测的格子列表，对应的，我们把检测过的格子放入Close List中。 以上是A的关键点，尤其是启发函数，如果没有启发函数，则A就退化成了Dijkstra算法，是运行效率重要还是找到最佳路径重要，全靠启发函数来调节，因此也被归为启发式算法。 A*算法的具体步骤： 把起点加入 open list 。 重复如下过程： 遍历 open list ，查找 F 值最小的节点，把它作为当前要处理的节点。 把这个节点移到 close list 。 对当前方格的 8 个相邻方格的每一个方格？(1). 如果它是不可抵达的或者它在 close list 中，忽略它。否则，做如下操作。(2). 如果它不在 open list 中，把它加入 open list ，并且把当前方格设置为它的父亲，记录该方格的 F ， G 和 H 值。(3). 如果它已经在 open list 中，检查这条路径 ( 即经由当前方格到达它那里 ) 是否更好，用 G 值作参考。更小的 G 值表示这是更好的路径。如果是这样，把它的父亲设置为当前方格，并重新计算它的 G 和 F 值。如果你的 open list 是按 F 值排序的话，改变后你可能需要重新排序。 停止，当你(1). 把终点加入到了 open list 中，此时路径已经找到了(2). 查找终点失败，并且 open list 是空的，此时没有路径。 保存路径。从终点开始，每个方格沿着父节点移动直至起点，这就是你的路径。程序运行截图 好了，就讲到这里了。程序源码点我查看]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用github+hexo搭建个人博客]]></title>
      <url>%2F2017%2F04%2F22%2Fuse-github-and-hexo-build-blog%2F</url>
      <content type="text"><![CDATA[概述 这个是本站的第一篇文章，我们该写点什么呢？很简单我们就写下本站是怎么搭建的吧。我们需要用到的框架是HEXO： 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 搭建node.js环境在安装HEXO之前需要先安装: Node.js Git 现在我们开始搭建Node.js环境，我这里以安装windows（win8.1）平台为例。点击上面的Node.js下载对应的版本 下载好后双击运行，跟着安装向导走就可以了，这里不多说。安装完成后正常情况下会自动设置好环境变量。 点击开始-运行-cmd（win+R），打开dos，输入node -v检查Node.js版本：出现上述输出则表示你已经成功安装node.js 使用cmd命令行输入npm -v来测试是否安装成功,如果成功会输出npm的版本号，这里就不放图片了。 好了到这一步node.js已经装好了。详细教程可以参考这里 安装git点击上面的Git链接会打开如下页面： 下载好后，双击运行安装程序，跟着向导安装就好了。 关于git的一些基本使用命令可以参考这里点我 安装HEXO 哈哈！！！终于到这一步了，其实这一步很简单，因为前面的安装好了这里用npm会非常简单哦。 1npm install -g hexo-cli 安装完成以后输入 hexo -v出现如下界面则表示Hexo安装成功了: 接下可以初始化我们的博客了，分别执行下面的命令（有没有很激动呢。。。） 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 依赖项装完以后可以在本地预览 首先执行hexo generate生成博客的静态页面 然后执行hexo server开启本地预览，在浏览器打开 http://localhost:4000/ 哈哈，有没有看到上述页面。到这里博客就创建好了。 _config.yml配置具体配置请参考这里 部署到github 注册github：部署到github自然需要有一个github账号啦。这个没什么好说的了。 新建创库，这个用文字表达起来会略显繁琐，所以这里直接上图 创建好仓库以后，我们需要打开_config.yml文件，添加如下内容 123type: gitrepository: https://github.com/yourname/yourname.github.iobranch: master 现在就差最后一步就可以部署到github了（很激动有没有，博客终于可以上线了，哈哈。。。）。now，执行下面的命令$ npm install hexo-deployer-git --save。最后一步部署命令$ hexo deploy。 到这里本教程就完成了。赶紧打开浏览器输入http://yourgitname.gihub.io 看看你的成果吧。ps：第一次用MarkDown来写博客，写的不好莫怪哈。有错请指正。]]></content>
    </entry>

    
  
  
</search>
